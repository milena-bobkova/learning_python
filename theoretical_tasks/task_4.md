# Теоретичне завдання 04
## Що таке складність алгоритму? Big O нотація? Яка складність алгоритму у випадку, якщо наш код містить цикл? Вкладений цикл?
  Складність алгоритму - це поняття того, як зростатиме витрата ресурсів зі збільшенням розміру вхідних даних. 

  Можна виділити такі основні складові складності алгоритму:
    1. Логічна складність — кількість людино-місяців, витрачених на створення алгоритму.
    2. Статична складність — довжина опису алгоритмів (кількість операторів).
    3. Часова складність — час виконання алгоритму.
    4. Ємнісна складність — кількість умовних одиниць пам'яті, необхідних для роботи алгоритму.
  Складність алгоритму дозволяє визначитися з вибором ефективного алгоритму серед тих, що побудовані для розв’язання конкретної проблеми.
  
  `Big O` - це відносне представлення складності алгоритму. При цьому ця характеристика завжди показує найгірший варіант розвитку подій - верхню межу. Ми частково використовуємо `Big O`, щоб полегшити проблему опису, наскільки «хороший» алгоритм. В такому випадку кажемо, що алгоритм A має часову складність `O(log n)`, якщо він швидкий, або `O(n²)`, наприклад, якщо повільний. Значення в круглих дужках `O()` має описувати порядок величини, в якому алгоритм є швидким або повільним щодо розміру вхідних даних. Це і дало назву `Big О`. Варто зазначити, що кількість часу та простору, які потрібні для запуску алгоритму не враховуються в `Big O`. Це спосіб наближено оцінити, наскільки збільшиться час виконання та об'єм пам'яті при збільшені вхідних даних.

  Поширені складності алгоритмів:
  
  * Якщо час роботи алгоритму не залежить від обсягу вхідних даних, то його часову складність позначають як `O(1)`.
  * Лінійна складність `O(n)`: подвоєння розміру задачі подвоїть і необхідний час.
  * Квадратична складність `O(n2)`: час роботи алгоритму зростає пропорційно квадрату кількості оброблюваних елементів, подвоєння розміру задачі вчетверо збільшує необхідний час.
  * Кубічна складність `O(n3)`: подвоєння розміру задачі збільшує необхідний час у вісім разів.

  Складність алгоритму в разі використання циклу - лінійна `O(n)`. Більший масив - більше операцій ми робимо для обчислення.

  Складність алгоритму з подвійним вкладеним циклом уже значно вища, за кожний елемент масиву нам потрібно зробити повну ітерацію по масиву. Тобто, маючи лише масив із п'яти елементів `[1, 2, 3, 4, 5]`, ми виконаємо 25 операцій. Застосувавши найпростішу математику, ми можемо дійти до того, що нам потрібен квадрат операцій на наш розмір вхідних даних. Ця складність називається квадратичною і позначається `O(n2)`.

## Що таке comprehensions в Python? Які вони є та для чого існують? 
  У Python присутня синтаксична конструкція, яка дає змогу в один рядок заповнювати списки простими або складними значеннями. Називається вона - генератори списків або `List Comprehensions`. 

  `List Comprehension` - це спрощений підхід до створення списку, який задіює цикл `for`, а також інструкції `if-else` для визначення того, що зрештою опиниться у фінальному списку.

  `List Comprehension` записується в квадратних дужках і задіює цикл `for`. У процесі створюється новий список, куди додаються всі елементи оригінального. У міру додавання елементів їх можна змінювати.

  ### Створення першого `list comprehension`.

    ```
    >>> nums = [n for n in range(1,6)]
    >>> print(nums)
    [1, 2, 3, 4, 5]
    ```

  У цьому прикладі кожне значення діапазону присвоюється змінній `n`. 
  Кожне значення повертається незмінним і додається в новий список. Це - та сама `n` перед циклом `for`.

  ### `List Comprehension` зі змінюванням
  Додамо змінювання для кожного значення в циклі.

    ```
    >>> nums = [1, 2, 3, 4, 5]
    >>> squares = [n*n for n in nums]
    >>> print(squares) 
    [1, 4, 9, 16, 25]
    ```

  У цьому прикладі дві зміни порівняно з минулим кодом. По-перше, як джерело використовується вже існуючий список. 
  По-друге, `list comprehension` створює список, де кожне значення - це піднесене до квадрата значення оригінального списку.

  ### `List comprehension` з `if`
  Інструкція `if` йде після циклу - у цьому випадку порядок відіграє роль.

    ```
    >>> nums = [1, 2, 3, 4, 5]
    >>> odd_squares = [n*n for n in nums if n%2 == 1]
    >>> print(odd_squares)
    [1, 9, 25]
    ```

  ### `List comprehension` із вкладеним циклом `for`

    ```
    >>> matrix = [
        [x for x in range(1, 4)]
        for y in range(1, 4)
        ]
    >>> print(matrix)
    [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
    ```

  Якщо в умові потрібен `else`, то вся умова пишеться до `for`.

    ```
    >>> [x ** 2 if x % 2 == 0 else x ** 3 for x in range(10)]
    [0, 1, 4, 27, 16, 125, 36, 343, 64, 729]
    ```
  
  У python є й генератори словників, записуються так само, як і генератори списків, тільки у фігурних дужках `{ ... }`.

  ```
  >>> {key: value for key, value in zip([1, 2, 3], ['a', 'b', 'c'])}
  {1: 'a', 2: 'b', 3: 'c'}
  ```

## Яка додаткова гілка є в цикла while?
  Так само, як і з циклами `for`, з циклами `while` можна використовувати додатковий блок `else`. 

  Блок `else` почне виконуватися, коли умова циклу `while` стане рівною `False`.

  Цикл `while` можна примусово завершити за допомогою інструкції `break`. У таких випадках блок `else` ігнорується. Інакше кажучи, блок `else` виконується тільки в тому випадку, якщо всередині тіла `while` не використовувався оператор `break`, а умова циклу `while` хибна. 

## Що таке ітератор?
  Ітератор являє собою об'єкт перечислювач, який для даного об'єкта видає наступний елемент, або кидає виняток, якщо елементів більше немає. Ітератор — це поведінковий патерн, що дозволяє послідовно обходити складну колекцію, не розкриваючи деталі її реалізації.

  Патерн можна часто зустріти в Python-коді, особливо в програмах, що працюють з різними типами колекцій, коли потрібно виконати обхід різних сутностей.

  Ітератор легко визначити за методами навігації (наприклад, отримання наступного/попереднього елементу і т. д.). Код, який використовує ітератор, часто взагалі не має посилань на колекцію, з якою працює ітератор. Ітератор або приймає колекцію в параметрах конструктора під час створення, або повертається до самої колекцією.

  Основне місце використання ітераторів - це цикл `for`. Якщо ви перебираєте елементи в деякому списку або символи в рядку за допомогою циклу `for`, то, фактично, це означає, що під час кожної ітерації циклу відбувається звернення до ітератора, який міститься в рядку/списку, з вимогою видати наступний елемент, якщо елементів в об'єкті більше немає, то ітератор генерує виняток, який обробляється в рамках циклу for непомітно для користувача.

  Об'єкти, елементи яких можна перебирати в циклі `for`, містять у собі об'єкт ітератор, для того, щоб його отримати, необхідно використовувати функцію `iter()`, а для вилучення наступного елемента з ітератора - функцію `next()`. Виклик функції `next()` щоразу повертає наступний елемент зі списку, а коли ці елементи закінчуються, генерується виняток `StopIteration`.

## Що таке генератор?

  Генератори дають змогу значно спростити роботу з конструювання ітераторів. Генератор - це функція, яка будучи викликаною у функції `next(`) повертає наступний об'єкт згідно з алгоритмом її роботи. Замість ключового слова `return` у генераторі використовується `yield`. При виклику `yield` функція не припиняє свою роботу, а "заморожується" до чергової ітерації, що запускається функцією `next()`.

  Якщо ви у своєму генераторі, десь використовуєте ключове слово `return`, то дійшовши до цього місця буде викинуто виняток `StopIteration`, а якщо після ключового слова `return` помістити будь-яку інформацію, то вона буде додана до опису `StopIteration`.