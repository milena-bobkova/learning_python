# Теоретичне завдання 03

## Розібратись із внутрішньою структурою set і dict. Що вони собою являють зсередини? Що таке хеш таблиці?
  Множина `set` — колекція, яка не має доступу за індексом. Будь-який елемент у множині може міститися тільки один раз.

  Множина має швидку операцію перевірки наявності елементу в собі за допомогою `in` та надає базові функції роботи із множинами. Ще одним обмеженням множин є те, що вони не можуть містити елементи, що змінюються (mutable), такі як словники та списки.

  Можлива конвертація будь-якого ітератора у множину за допомогою конструктора класу. Якщо ітератор повертає якісь елементи кілька разів, вони будуть проігноровані.

  Оскільки множина є ітератором, то можливе, наприклад, її перетворення у список. Це часто використовують, щоб отримати список, який містить тільки унікальні елементи.

  Ммножина не гарантує зберігання порядку елементів.

  Більшість операцій над множинами має дві форми — оператора та метода множини. Основна відмінність в тому, що оператор вимагає, щоб обидва операнди були множинами, а методи у переважній більшості дозволяють використати ітератор як другий аргумент. В цьому випадку він буде автоматично конвертований у множину.

  Словник `dict` - тип даних, вбудований у Python. 

  Словники - невпорядковані колекції довільних об'єктів із доступом за ключем. Їх іноді ще називають асоціативними масивами або хеш-таблицями.

  Щоб працювати зі словником, його потрібно створити. Для його створення використовується традиційний синтаксис.
    
  ```
    dict1 = {
    "John": 20,
    "Paul": "string",
    "Jones": 37.7,
    20: "dynamic"
    }

    dict2 = {}
    dict2["Ringo"] = "Starr"  
  ```

  Можна використати словниковий літерал, або створити порожній словник та додати туди значення, проте перший варіант вважається кращим.

  Оскільки Python є динамічною мовою, тут немає потреби використовувати однакові типи даних для ключів та значень.

  Для доступу до окремого елементу словника можна використовувати звичайний синтаксис: `dict1[20]`. Якщо ключ не міститься у словнику, буде згенеровано виняток `KeyError`. Найпростішим методом запобігти винятку є використання методу `get(key, default_value=None)`.

  Починаючи з версії 3.7, Python гарантує збереження порядку ключів.  

  Хеш-таблиці - це тип структури даних, у якій адреса або значення індексу елемента даних генеруються з хеш-функції. Це прискорює доступ до даних, оскільки значення індексу поводиться як ключ до значення даних. Іншими словами, у хеш-таблиці зберігаються пари ключ-значення, але ключ генерується за допомогою функції хешування.

  У Python типи даних `Dictionary` представляють реалізацію хеш-таблиць. Ключі в словнику задовольняють таким вимогам.

  - Ключі словника є хешованими, тобто генеруються хеш-функцією, яка генерує унікальний результат для кожного унікального значення, переданого хеш-функції.
  - Порядок елементів даних у словнику не є фіксованим.

## Які значення можуть бути елементами множини і ключами словника? Чому?

  Це числа, рядки, кортежі.

  Елементами множини може бути будь-який незмінний тип даних: числа, рядки, кортежі.

  Ключами словника можуть бути тільки об'єкти, що підтримують хешування. Таким чином, використовувати як ключі списки, словники та інші змінювані типи не вийде. Таким чином, ключами словника може бути довільний незмінний тип даних: цілі та дійсні числа, рядки, кортежі.


## Знайди інформацію про frozen set . Просто знай, що це і, що вони існують))
  
  Окрім звичайних множин, в Python існують також «заморожені множини», які створюються за допомогою конструктора `frozenset`. Їх відмінність полягає в тому, що в них немає можливостей зміни самої множини (додавання елементів, вилучення і таке інше). Скорочені оператори для таких множин не модифікують операнд ліворуч, а створюють нову множину та зберігають її у відповідній змінній.

## Знайти в PEP 20 та PEP 8 рекомендації, що стосуються використання конструкції if та вкладеності.
  ### PEP-8
  
  Коли умовна частина оператора `if` досить довга і вимагає запису в декілька рядків, варто звернути увагу на те, що комбінація ключового слова з двох символів (тобто `if`), плюс один пробіл, плюс відкриваюча дужка створює природний відступ у 4 пробіли для наступних рядків багаторядкової умови. Це може призвести до візуального конфлікту з набором коду з відступами, вкладеним в інструкцію `if`, який також, природно, матиме відступ у 4 пробіли. Цей ПЕП не містить чіткої позиції щодо того, як (і чи потрібно) додатково візуально відрізняти такі умовні рядки від вкладеного набору всередині `if`-оператора. Прийнятні варіанти в цій ситуації включають, але не обмежуються ними.

  Хоча іноді можна розміщувати оператори `if/for/while` з невеликим тілом в одному рядку, ніколи не робіть цього в операторах, що складаються з декількох пунктів. Також уникайте згортання таких довгих рядків!

  Остерігайтеся писати `if x`, коли ви насправді маєте на увазі `if x is not None` - наприклад, при перевірці того, чи змінна або аргумент, який за замовчуванням має значення `None`, був встановлений в якесь інше значення. Інше значення може мати тип (наприклад, контейнер), який може бути хибним у логічному контексті!

## Знайти опис оператора case, який нещодавно з’явився в Python. Чому використовувати класичний if/else все ж таки вважаєтсья кращою практикою?

  В Python дуже часто потрібно перевіряти дані на відповідність типів, звертатися до даних за індексом і до цих же даних застосовувати перевірку на тип. Також часто доводиться перевіряти не тільки тип даних, а й кількість, що призводить до появи величезної кількості гілок `if/else` з викликом функцій `isinstance`, `len і` зверненням до елементів за індексом, ключем або атрибутом. Саме для спрощення роботи і зменшення `is/else` було введено новий оператор `match/case`.

  Дуже важливо не плутати pattern matching і `switch/case`, їхня головна відмінність полягає в тому, що `pattern matching` - це не просто оператор для порівняння деякої змінної зі значеннями, це цілий механізм для перевірки даних, їхнього розпакування та управління потоком виконання. 

  Новий оператор спрощує життя розробникам, беручи на себе роботу з перевіркою типів даних або приналежністю до певного класу.

  Якщо в застосунку є перевірки на форми введення, або перевірки `if/else` занадто великі, але перевірки виконуються не дуже часто (наприклад, під час кліка користувача на кнопку), то оператор match/case може стати гарною альтернативою `if/else`, тому що він поєднує в собі багато хороших функцій. 

  Але за продуктивністю він поступається `if/else`. Якщо ви займаєтеся будь-яким обчисленнями на Python, або у вашому застосунку багато циклів/багато перевірок - НЕ варто використовувати оператор `match/case`, бо він може сповільнити виконання коду в кілька разів.

## Ознайомитись із методами словників та множин.

  Методи множин:

  З множинами можна виконувати безліч операцій: знаходити об'єднання, перетин...

  * `len(s)` - число елементів у множині (розмір множини).
  * `x in s` - чи належить `x` множині `s`.
  * `set.isdisjoint(other)` - істина, якщо `set` і `other` не мають спільних елементів.
  * `set == other` - усі елементи `set` належать `other`, усі елементи `other` належать `set`.
  * `set.issubset(other)` або `set <= other` - усі елементи `set` належать `other`.
  * `set.issuperset(other)` або `set >= other` - аналогічно.
  * `set.union(other, ...)` або `set | other | ...` - об'єднання кількох множин.
  * `set.intersection(other, ...)` або `set & other & ...` - перетин.
  * `set.difference(other, ...)` або `set - other - ...` - множина з усіх елементів `set`, що не належать жодному з `other`.
  * `set.symmetric_difference(other)`; `set ^ other` - множина з елементів, що трапляються в одній множині, але не трапляються в обох.
  * `set.copy()` - копія множини.

  І операції, що безпосередньо змінюють множину:

  * `set.update(other, ...)`; `set |= other | ...` - об'єднання.
  * `set.intersection_update(other, ...)`; `set &= other & ...` - перетин.
  * `set.difference_update(other, ...)`; `set -= other | ...` - віднімання.
  * `set.symmetric_difference_update(other)`; `set ^= other` - множина з елементів, які зустрічаються в одній множині, але не зустрічаються в обох.
  * `set.add(elem)` - додає елемент у множину.
  * `set.remove(elem)` - видаляє елемент із множини. KeyError, якщо такого елемента не існує.
  * `set.discard(elem)` - видаляє елемент, якщо він знаходиться в множині.
  * `set.pop()` - видаляє перший елемент із множини. Оскільки множини не впорядковані, не можна точно сказати, який елемент буде першим.
  * `set.clear()` - очищення множини.

  Методи словників:

  * `dict.clear()` - очищає словник.
  * `dict.copy()` - повертає копію словника.
  * `classmethod dict.fromkeys(seq[, value])` - створює словник із ключами з seq і значенням value (за замовчуванням None).
  * `dict.get(key[, default])` - повертає значення ключа, але якщо його немає, не кидає виняток, а повертає default (за замовчуванням None).
  * `dict.items()` - повертає пари (ключ, значення).
  * `dict.keys()` - повертає ключі в словнику.
  * `dict.pop(key[, default])` - видаляє ключ і повертає значення. Якщо ключа немає, повертає default (за замовчуванням кидає виняток).
  * `dict.popitem()` - видаляє і повертає пару (ключ, значення). Якщо словник порожній, кидає виняток KeyError. Пам'ятайте, що словники невпорядковані.
  * `dict.setdefault(key[, default])` - повертає значення ключа, але якщо його немає, не кидає виняток, а створює ключ зі значенням default (за замовчуванням None).
  * `dict.update([other])` - оновлює словник, додаючи пари (ключ, значення) з other. Існуючі ключі перезаписуються. Повертає None (не новий словник!).
  * `dict.values()` - повертає значення в словнику.